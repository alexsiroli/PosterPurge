Struttura del progetto:
PosterForge/
    .DS_Store
    Info.plist
    LaunchScreen.storyboard
    output.txt
    print.py
    PosterForgeUITests/
        PosterForgeUITests.swift
        PosterForgeUITestsLaunchTests.swift
    PosterForgeTests/
        PosterForgeTests.swift
    PosterForge/
        PosterForgeApp.swift
        ViewModels/
            LibraryViewModel.swift
            PosterGenerator.swift
        Assets.xcassets/
            Contents.json
            AppIcon.appiconset/
                1024.png
                114.png
                120.png
                180.png
                29.png
                40.png
                57.png
                58.png
                60.png
                80.png
                87.png
                Contents.json
            AccentColor.colorset/
                Contents.json
            LaunchScreen.imageset/
                Contents.json
                Image.png
        Models/
            MovieModel.swift
            PosterItem.swift
            UserPreferences.swift
        Preview Content/
            Preview Assets.xcassets/
                Contents.json
        Theme/
            Theme.swift
        Views/
            AsyncImageLoader.swift
            CSVImportView.swift
            ContentView.swift
            LibraryView.swift
            PosterDetailView.swift
            SearchView.swift
            SettingsView.swift
        Services/
            CSVParser.swift
            TMDbService.swift
    PosterForge.xcodeproj/
        project.pbxproj
        xcuserdata/
            alexsiroli.xcuserdatad/
                xcschemes/
                    xcschememanagement.plist
        project.xcworkspace/
            contents.xcworkspacedata
            xcuserdata/
                alexsiroli.xcuserdatad/
                    UserInterfaceState.xcuserstate
            xcshareddata/
                swiftpm/
                    configuration/

Contenuti dei file .swift:

========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForgeUITests/PosterForgeUITests.swift
========================================
// ========================================
// File: PosterForgeUITests.swift
// ========================================
import XCTest

final class PosterForgeUITests: XCTestCase {

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    override func tearDownWithError() throws {}

    @MainActor
    func testExample() throws {
        let app = XCUIApplication()
        app.launch()

        // Esempio di test UI
        XCTAssertTrue(app.buttons["1) Carica CSV"].exists)
        XCTAssertTrue(app.buttons["2) Cerca un Film / Serie"].exists)
        XCTAssertTrue(app.buttons["3) Mostra Libreria"].exists)
    }

    @MainActor
    func testLaunchPerformance() throws {
        if #available(iOS 13.0, *) {
            measure(metrics: [XCTApplicationLaunchMetric()]) {
                XCUIApplication().launch()
            }
        }
    }
}


========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForgeUITests/PosterForgeUITestsLaunchTests.swift
========================================
// ========================================
// File: PosterForgeUITestsLaunchTests.swift
// ========================================
import XCTest

final class PosterForgeUITestsLaunchTests: XCTestCase {

    override class var runsForEachTargetApplicationUIConfiguration: Bool { true }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}


========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForgeTests/PosterForgeTests.swift
========================================
// ========================================
// File: PosterForgeTests.swift
// ========================================
import Testing
@testable import PosterForge

struct PosterForgeTests {

    @Test func example() async throws {
        // Esempio di test col nuovo Swift Testing (se disponibile)
        // #expect(true, ==, true)
    }
}


========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForge/PosterForgeApp.swift
========================================
import SwiftUI

@main
struct PosterForgeApp: App {
    @StateObject var preferencesManager = PreferencesManager()

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(preferencesManager)
        }
    }
}


========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForge/ViewModels/LibraryViewModel.swift
========================================
import SwiftUI

class LibraryViewModel: ObservableObject {
    @Published var posters: [PosterItem] = []

    private let libraryKey = "PosterForgeLibrary"
    private let folderName = "PosterForgeImages"

    init() {
        loadLibrary()
        // Ascoltiamo la notifica di reset
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleLibraryReset),
            name: .libraryResetRequested,
            object: nil
        )
    }

    @objc private func handleLibraryReset() {
        // Rimuoviamo tutti i file e svuotiamo l'array
        for p in posters {
            deleteImageFromDisk(poster: p)
        }
        posters.removeAll()

        // Cancelliamo pure il file JSON
        let jsonURL = libraryURL()
        do {
            if FileManager.default.fileExists(atPath: jsonURL.path) {
                try FileManager.default.removeItem(at: jsonURL)
            }
        } catch {
            print("Errore eliminando library JSON:", error)
        }

        DispatchQueue.main.async {
            self.objectWillChange.send()
        }
    }

    // MARK: - Aggiunta/Rimozione Poster
    func addPoster(_ poster: PosterItem) {
        posters.append(poster)
        saveLibrary()
    }

    func removePoster(_ poster: PosterItem) {
        posters.removeAll { $0.id == poster.id }
        deleteImageFromDisk(poster: poster)
        saveLibrary()
    }

    // MARK: - Salvataggio Libreria su Disco
    func saveLibrary() {
        do {
            let folderURL = imagesFolderURL()
            if !FileManager.default.fileExists(atPath: folderURL.path) {
                try FileManager.default.createDirectory(at: folderURL, withIntermediateDirectories: true, attributes: nil)
            }

            let itemsForJSON = posters.map { poster -> PosterItemDTO in
                var imageFilename: String? = poster.imageFilename
                if imageFilename == nil, let uiImage = poster.uiImage {
                    imageFilename = saveImageToDisk(uiImage: uiImage, id: poster.id)
                }
                return PosterItemDTO(
                    id: poster.id,
                    movie: poster.movie,
                    timestamp: poster.timestamp,
                    imageFilename: imageFilename
                )
            }

            let data = try JSONEncoder().encode(itemsForJSON)
            let jsonURL = libraryURL()
            try data.write(to: jsonURL)

        } catch {
            print("Errore nel salvataggio libreria: \(error)")
        }
    }

    // MARK: - Caricamento Libreria da Disco
    func loadLibrary() {
        let jsonURL = libraryURL()
        guard FileManager.default.fileExists(atPath: jsonURL.path) else { return }

        do {
            let data = try Data(contentsOf: jsonURL)
            let decoded = try JSONDecoder().decode([PosterItemDTO].self, from: data)

            let loadedItems: [PosterItem] = decoded.map { dto in
                let possibleImage = loadImageFromDisk(filename: dto.imageFilename)
                return PosterItem(
                    id: dto.id,
                    movie: dto.movie,
                    uiImage: possibleImage,
                    timestamp: dto.timestamp,
                    imageFilename: dto.imageFilename
                )
            }
            self.posters = loadedItems
        } catch {
            print("Errore nel caricamento libreria: \(error)")
            self.posters = []
        }
    }

    // MARK: - Supporto Immagini
    private func saveImageToDisk(uiImage: UIImage, id: UUID) -> String? {
        let folderURL = imagesFolderURL()
        let filename = "\(id.uuidString).png"
        let fileURL = folderURL.appendingPathComponent(filename)
        guard let pngData = uiImage.pngData() else { return nil }
        do {
            try pngData.write(to: fileURL)
            return filename
        } catch {
            print("Errore salvando immagine su disco: \(error)")
            return nil
        }
    }

    private func loadImageFromDisk(filename: String?) -> UIImage? {
        guard let filename = filename else { return nil }
        let fileURL = imagesFolderURL().appendingPathComponent(filename)
        if let data = try? Data(contentsOf: fileURL),
           let image = UIImage(data: data) {
            return image
        }
        return nil
    }

    private func deleteImageFromDisk(poster: PosterItem) {
        guard let filename = poster.imageFilename else { return }
        let fileURL = imagesFolderURL().appendingPathComponent(filename)
        do {
            try FileManager.default.removeItem(at: fileURL)
        } catch {
            print("Errore cancellando immagine: \(error)")
        }
    }

    // MARK: - Path
    private func libraryURL() -> URL {
        let docs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        return docs.appendingPathComponent("\(libraryKey).json")
    }

    private func imagesFolderURL() -> URL {
        let docs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        return docs.appendingPathComponent(folderName)
    }
}

struct PosterItemDTO: Codable {
    let id: UUID
    let movie: MovieModel
    let timestamp: Date
    let imageFilename: String?
}


========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForge/ViewModels/PosterGenerator.swift
========================================
import UIKit
import CoreGraphics
import CoreImage

class PosterGenerator {
    static let shared = PosterGenerator()

    private let iphoneWidth: CGFloat = 1179
    private let iphoneHeight: CGFloat = 2556

    // Layout Tradizionale
    private let tradQuadX: CGFloat = 190
    private let tradQuadY: CGFloat = 700
    private let tradQuadW: CGFloat = 800
    private let tradQuadH: CGFloat = 1400

    private let tradPosterW: CGFloat = 682
    private let tradPosterH: CGFloat = 1023
    private let tradPosterX: CGFloat = 250
    private let tradPosterY: CGFloat = 960

    private let tradTitlePoint = CGPoint(x: 247, y: 749)
    private let tradYearPoint = CGPoint(x: 893, y: 749)

    // Stelle
    private let tradStarsYAdjust: CGFloat = 250 // spostamento in basso
    private let tradStarSize: CGFloat = 35
    private let tradStarSpacing: CGFloat = 10

    // Layout Moderno
    private let altBoxX: CGFloat = 86
    private let altBoxY: CGFloat = 736
    private let altBoxW: CGFloat = 1007
    private let altBoxH: CGFloat = 1007
    private let altBoxCorner: CGFloat = 32

    func generatePoster(baseImage: UIImage, layout: String, movie: MovieModel) -> UIImage? {
        if layout == "modern" {
            return generateModern(base: baseImage, movie: movie)
        } else {
            return generateTraditional(base: baseImage, movie: movie)
        }
    }

    // MARK: - TRADITIONAL
    private func generateTraditional(base: UIImage, movie: MovieModel) -> UIImage? {
        let size = CGSize(width: iphoneWidth, height: iphoneHeight)
        UIGraphicsBeginImageContextWithOptions(size, false, 1.0)
        guard let context = UIGraphicsGetCurrentContext() else { return nil }

        let bgColor = averageColor(baseImage: base) ?? .white
        bgColor.setFill()
        context.fill(CGRect(origin: .zero, size: size))

        // Riquadro
        let rect = CGRect(x: tradQuadX, y: tradQuadY, width: tradQuadW, height: tradQuadH)
        UIColor.white.setFill()
        context.fill(rect)
        context.setStrokeColor(UIColor.black.cgColor)
        context.setLineWidth(15)
        context.stroke(rect)

        // Poster
        let posterRect = CGRect(x: tradPosterX, y: tradPosterY, width: tradPosterW, height: tradPosterH)
        if let resized = base.resize(to: CGSize(width: tradPosterW, height: tradPosterH)) {
            resized.draw(in: posterRect)
        }

        // Titolo
        let titleFont = UIFont.boldSystemFont(ofSize: 64)
        let titleAttrs: [NSAttributedString.Key : Any] = [
            .font: titleFont, .foregroundColor: UIColor.black
        ]
        movie.title.draw(at: tradTitlePoint, withAttributes: titleAttrs)

        // Anno 2 righe
        let yearFont = UIFont.boldSystemFont(ofSize: 26)
        let year = movie.year
        if year.count == 4 {
            let style = NSMutableParagraphStyle()
            style.lineSpacing = 0
            style.alignment = .left
            let compound = "\(year.prefix(2))\n\(year.suffix(2))"
            let attributed = NSAttributedString(string: compound, attributes: [
                .font: yearFont,
                .foregroundColor: UIColor.black,
                .paragraphStyle: style
            ])
            attributed.draw(at: tradYearPoint)
        } else {
            let yearAttrs: [NSAttributedString.Key : Any] = [
                .font: yearFont, .foregroundColor: UIColor.black
            ]
            movie.year.draw(at: tradYearPoint, withAttributes: yearAttrs)
        }

        // Stelle
        let starCount = 10
        let totalWidth = CGFloat(starCount) * tradStarSize + CGFloat(starCount - 1)*tradStarSpacing
        let rMidX = rect.midX
        let startX = rMidX - totalWidth/2
        let baseY = CGFloat(2000 + tradStarsYAdjust)
        let rating = max(0, min(movie.rating, 10))
        for i in 0..<starCount {
            let x = startX + CGFloat(i)*(tradStarSize+tradStarSpacing)
            let starRect = CGRect(x: x, y: baseY, width: tradStarSize, height: tradStarSize)
            let starImage = (i<rating) ? UIImage(systemName: "star.fill") : UIImage(systemName: "star")
            starImage?.withTintColor(.black, renderingMode: .alwaysOriginal).draw(in: starRect)
        }

        let final = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        return final
    }

    // MARK: - MODERN
    private func generateModern(base: UIImage, movie: MovieModel) -> UIImage? {
        let size = CGSize(width: iphoneWidth, height: iphoneHeight)
        UIGraphicsBeginImageContextWithOptions(size, false, 1.0)
        guard let ctx = UIGraphicsGetCurrentContext() else { return nil }

        let baseAvg = averageColor(baseImage: base) ?? .darkGray
        let cTop = baseAvg.darker(by: 30)
        let cBot = UIColor.black
        let gradColors = [cTop.cgColor, cBot.cgColor] as CFArray
        let locs: [CGFloat] = [0, 1]
        let space = CGColorSpaceCreateDeviceRGB()
        if let grad = CGGradient(colorsSpace: space, colors: gradColors, locations: locs) {
            ctx.drawLinearGradient(grad, start: .zero, end: CGPoint(x:0, y:size.height), options: [])
        }

        let boxRect = CGRect(x: altBoxX, y: altBoxY, width: altBoxW, height: altBoxH)
        UIColor(white: 1, alpha: 0.8).setFill()
        let boxPath = UIBezierPath(roundedRect: boxRect, cornerRadius: altBoxCorner)
        boxPath.fill()

        // Poster intero
        let posterRectH = boxRect.height - 60
        let ratio = base.size.width / base.size.height
        let computedW = posterRectH * ratio
        let finalPosterRect = CGRect(
            x: boxRect.maxX - computedW - 30,
            y: boxRect.minY + 30,
            width: computedW,
            height: posterRectH
        )
        if let resized = base.resize(to: CGSize(width: computedW, height: posterRectH)) {
            let posterClip = UIBezierPath(roundedRect: finalPosterRect, cornerRadius:20)
            posterClip.addClip()
            resized.draw(in: finalPosterRect)
        }

        // Anno
        let yearFont = UIFont.boldSystemFont(ofSize:36)
        let yearAttrs:[NSAttributedString.Key:Any] = [
            .font: yearFont,
            .foregroundColor: UIColor.black
        ]
        let yearPoint = CGPoint(x: boxRect.minX + 40, y: boxRect.minY + 40)
        movie.year.draw(at: yearPoint, withAttributes: yearAttrs)

        // Titolo
        let tFont = UIFont.boldSystemFont(ofSize:44)
        let pStyle = NSMutableParagraphStyle()
        pStyle.lineBreakMode = .byWordWrapping
        let tAttrs:[NSAttributedString.Key:Any] = [
            .font: tFont,
            .foregroundColor: UIColor.black,
            .paragraphStyle: pStyle
        ]
        let titleX = boxRect.minX + 40
        let titleY = yearPoint.y + 60
        let titleMaxW = boxRect.width - (computedW + 100)
        let rectTitle = CGRect(x: titleX, y: titleY, width: titleMaxW, height: 300)
        NSString(string: movie.title).draw(in: rectTitle, withAttributes: tAttrs)

        // Stelle
        let rating = max(0, min(movie.rating, 10))
        let starCount = 10
        let starSize: CGFloat = 40
        let starSpacing: CGFloat = 8
        let stTotW = CGFloat(starCount)*starSize + CGFloat(starCount-1)*starSpacing
        let stX = boxRect.midX - stTotW/2
        let stY = boxRect.maxY - 70
        for i in 0..<starCount {
            let x = stX + CGFloat(i)*(starSize+starSpacing)
            let stRect = CGRect(x:x, y:stY, width:starSize, height:starSize)
            if i<rating {
                UIImage(systemName: "star.fill")?
                    .withTintColor(.yellow, renderingMode: .alwaysOriginal)
                    .draw(in: stRect)
            } else {
                UIImage(systemName: "star")?
                    .withTintColor(.gray, renderingMode: .alwaysOriginal)
                    .draw(in: stRect)
            }
        }

        let final = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        return final
    }

    private func averageColor(baseImage: UIImage) -> UIColor? {
        guard let cg = baseImage.cgImage else {return nil}
        let w=1, h=1
        let space = CGColorSpaceCreateDeviceRGB()
        let raw = UnsafeMutablePointer<UInt8>.allocate(capacity:4)
        defer { raw.deallocate() }
        guard let cxt = CGContext(data: raw, width: w, height: h, bitsPerComponent:8, bytesPerRow:4, space: space, bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue) else{return nil}
        cxt.draw(cg, in:CGRect(x:0,y:0,width:1,height:1))
        let r = CGFloat(raw[0])/255.0
        let g = CGFloat(raw[1])/255.0
        let b = CGFloat(raw[2])/255.0
        let a = CGFloat(raw[3])/255.0
        return UIColor(red:r, green:g, blue:b, alpha:a)
    }
}

extension UIColor {
    func darker(by percentage: CGFloat=20.0)->UIColor{
        var h,s,b,a:CGFloat=(0,0,0,0)
        if getHue(&h, saturation:&s, brightness:&b, alpha:&a) {
            let nb = max(min(b-percentage/100.0,1.0),0.0)
            return UIColor(hue:h, saturation:s, brightness:nb, alpha:a)
        }
        return self
    }
}

extension UIImage {
    func resize(to target: CGSize)->UIImage?{
        UIGraphicsBeginImageContextWithOptions(target, false,1.0)
        draw(in: CGRect(origin:.zero,size:target))
        let newImg = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        return newImg
    }
}


========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForge/Models/MovieModel.swift
========================================
import SwiftUI

struct MovieModel: Identifiable, Equatable, Codable {
    let id = UUID()

    var title: String
    var year: String
    var rating: Int
    var dateWatched: String
    var isTV: Bool

    var normalizedTitle: String {
        return title
            .folding(options: .diacriticInsensitive, locale: .current)
            .replacingOccurrences(of: " ", with: "_")
            .replacingOccurrences(of: "/", with: "_")
            .lowercased()
    }
}


========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForge/Models/PosterItem.swift
========================================
import SwiftUI

struct PosterItem: Identifiable, Equatable {
    let id: UUID
    let movie: MovieModel
    var uiImage: UIImage?
    let timestamp: Date
    let imageFilename: String?

    var image: Image {
        guard let uiImage = uiImage else {
            return Image(systemName: "photo")
        }
        return Image(uiImage: uiImage)
    }
}


========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForge/Models/UserPreferences.swift
========================================
import SwiftUI

struct UserPreferences: Codable {
    var posterSelectionMode: String  // "automatic" o "manual"

    init(posterSelectionMode: String = "automatic") {
        self.posterSelectionMode = posterSelectionMode
    }
}

class PreferencesManager: ObservableObject {
    @Published var preferences: UserPreferences = UserPreferences()
    private let preferencesKey = "PosterForgeUserPreferences"

    init() {
        loadPreferences()
    }

    func loadPreferences() {
        guard let data = UserDefaults.standard.data(forKey: preferencesKey) else { return }
        if let decoded = try? JSONDecoder().decode(UserPreferences.self, from: data) {
            self.preferences = decoded
        }
    }

    func savePreferences() {
        if let encoded = try? JSONEncoder().encode(preferences) {
            UserDefaults.standard.set(encoded, forKey: preferencesKey)
        }
    }

    func resetPreferences() {
        preferences = UserPreferences()
        savePreferences()
    }
}


========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForge/Theme/Theme.swift
========================================
import SwiftUI

enum AppColor {
    static let primary = Color("Primary")
    static let secondary = Color("Secondary")
    static let backgroundGradient = Gradient(colors: [Color("GradientStart"), Color("GradientEnd")])
    static let cardBackground = Color(.systemBackground).opacity(0.8)
}

enum AppFont {
    static let title = Font.system(.largeTitle, design: .rounded).weight(.heavy)
    static let headline = Font.system(.headline, design: .rounded).weight(.semibold)
    static let body = Font.system(.body, design: .rounded)
}

enum AppStyle {
    static let cornerRadius: CGFloat = 16
    static let shadowRadius: CGFloat = 8
    static let cardPadding: CGFloat = 16
    static let buttonPadding: CGFloat = 14
}

extension View {
    func appCardStyle() -> some View {
        self
            .padding(AppStyle.cardPadding)
            .background(AppColor.cardBackground)
            .cornerRadius(AppStyle.cornerRadius)
            .shadow(color: .black.opacity(0.1), radius: AppStyle.shadowRadius, x:0,y:4)
    }
    func appButtonStyle() -> some View {
        self
            .padding(AppStyle.buttonPadding)
            .background(AppColor.primary)
            .foregroundColor(.white)
            .font(AppFont.headline)
            .cornerRadius(AppStyle.cornerRadius)
            .shadow(color: AppColor.primary.opacity(0.3), radius:8,x:0,y:4)
    }
}


========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForge/Views/AsyncImageLoader.swift
========================================
import SwiftUI
import UIKit

struct AsyncImageLoader: View {
    let url: URL?
    let placeholder: Image
    @State private var image: UIImage?
    @State private var isLoading = false
    @State private var error: Error?

    var body: some View {
        Group {
            if let image = image {
                Image(uiImage: image).resizable()
            } else if isLoading {
                ProgressView()
            } else {
                placeholder
            }
        }
        .onAppear(perform: loadImage)
    }
    
    private func loadImage() {
        guard let url = url else { return }
        isLoading = true
        URLSession.shared.dataTask(with: url) { data,_,err in
            DispatchQueue.main.async {
                self.isLoading = false
                if let e = err { self.error=e;return}
                if let data=data, let img=UIImage(data:data){
                    self.image=img
                }
            }
        }.resume()
    }
}


========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForge/Views/CSVImportView.swift
========================================
import SwiftUI
import UniformTypeIdentifiers

struct CSVImportView: View {
    @Environment(\.presentationMode) var presentationMode
    @EnvironmentObject var preferencesManager: PreferencesManager
    @ObservedObject var libraryVM: LibraryViewModel

    @State private var showDocumentPicker = false
    @State private var isProcessing = false
    @State private var progressText = "Seleziona un CSV..."

    @State private var pendingMovies: [MovieModel] = []
    @State private var currentIndex = 0
    @State private var posterImages: [UIImage] = []
    @State private var chosenPoster: UIImage?
    @State private var showingManualSheet = false
    
    // "Sbagliato film" sheet
    @State private var showingWrongFilmSheet = false
    @State private var searchResults: [TMDbService.TMDbSearchResult] = []
    @State private var searchQuery = ""
    @State private var isTV = false
    @State private var yearGuess: Int? = nil

    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                Text(progressText)
                    .font(.headline)
                    .multilineTextAlignment(.center)
                    .padding()

                if !isProcessing && pendingMovies.isEmpty {
                    Button {
                        showDocumentPicker = true
                    } label: {
                        Text("Scegli file CSV")
                            .font(.title3)
                            .padding()
                            .background(Color.blue.opacity(0.2))
                            .cornerRadius(8)
                    }
                }

                Spacer()
            }
            .padding()
            .navigationTitle("Import CSV")
            .navigationBarItems(leading: Button("Chiudi") {
                presentationMode.wrappedValue.dismiss()
            })
            .fileImporter(
                isPresented: $showDocumentPicker,
                allowedContentTypes: [.commaSeparatedText, .plainText],
                allowsMultipleSelection: false
            ) { result in
                handleFileImport(result: result)
            }
            .sheet(isPresented: $showingManualSheet) {
                manualSelectionSheet()
            }
            .sheet(isPresented: $showingWrongFilmSheet) {
                wrongFilmSheet()
            }
        }
    }

    // MARK: - Import CSV
    func handleFileImport(result: Result<[URL],Error>) {
        switch result {
        case .success(let urls):
            guard let url=urls.first else{return}
            importCSV(from:url)
        case .failure(let e):
            print("ERRORE selezione file CSV:", e.localizedDescription)
        }
    }

    func importCSV(from url: URL) {
        isProcessing=true
        progressText="Caricamento CSV..."

        DispatchQueue.global(qos:.userInitiated).async {
            do {
                var isAccessing = false
                if url.startAccessingSecurityScopedResource() {
                    isAccessing=true
                }
                defer {
                    if isAccessing {
                        url.stopAccessingSecurityScopedResource()
                    }
                }

                let csvString = try String(contentsOf:url, encoding:.utf8)
                let sanitized = csvString.replacingOccurrences(of: "\"", with:"")
                let movies = CSVParser.parseMovies(from:sanitized)
                if movies.isEmpty {
                    DispatchQueue.main.async {
                        self.progressText="Nessun film trovato nel CSV."
                        self.isProcessing=false
                    }
                    return
                }
                let existing = Set(self.libraryVM.posters.map{$0.movie.normalizedTitle})
                let newMovs = movies.filter{!existing.contains($0.normalizedTitle)}
                DispatchQueue.main.async {
                    self.startImportProcess(movies:newMovs)
                }

            } catch {
                DispatchQueue.main.async {
                    self.progressText="Errore lettura CSV"
                    self.isProcessing=false
                }
            }
        }
    }

    private func startImportProcess(movies:[MovieModel]) {
        guard !movies.isEmpty else {
            progressText="CSV import: Nessun film nuovo da importare."
            isProcessing=false
            return
        }
        let mode = preferencesManager.preferences.posterSelectionMode
        if mode=="automatic" {
            Task {await importAutomatically(movies:movies)}
        } else {
            self.pendingMovies=movies
            self.currentIndex=0
            showNextManualStep()
        }
    }

    // MARK: - Automatic
    private func importAutomatically(movies:[MovieModel]) async {
        progressText="Inizio import automatico (\(movies.count) film)..."
        isProcessing=true
        var processedCount=0
        for mov in movies {
            let yInt = Int(mov.year).flatMap{$0==0 ? nil : $0}
            do {
                let results = try await TMDbService.shared.search(
                    query: mov.title,
                    mediaType: mov.isTV ? .tv:.movie,
                    year:yInt
                )
                if let first=results.first {
                    // fetch images
                    let imgResp = try await TMDbService.shared.fetchImages(for: first.id, mediaType: mov.isTV ? .tv:.movie)
                    let posters = imgResp.posters.prefix(16)
                    if let bestPoster = posters.first,
                       let downloaded = try await TMDbService.shared.downloadImage(path: bestPoster.file_path) {
                        
                        // Carichiamo i dettagli in italiano (title e year corretti)
                        let details = try await fetchTMDbDetails(itemID: first.id, isTV: mov.isTV)
                        // Creiamo il MovieModel con i dati “title” e “year” da TMDb
                        let finalMovie = MovieModel(
                            title: details.title,
                            year: details.year,
                            rating: mov.rating,
                            dateWatched: mov.dateWatched,
                            isTV: mov.isTV
                        )
                        let item = PosterItem(
                            id: UUID(),
                            movie: finalMovie,
                            uiImage: downloaded,
                            timestamp: Date(),
                            imageFilename:nil
                        )
                        libraryVM.addPoster(item)
                    }
                }
            } catch {
                print("Errore (import automatico) su \"\(mov.title)\": \(error.localizedDescription)")
            }
            processedCount+=1
            progressText="Generati \(processedCount)/\(movies.count)"
        }
        progressText="Import automatico completato!"
        isProcessing=false
    }

    // MARK: - Manual
    private func showNextManualStep() {
        guard currentIndex<pendingMovies.count else {
            progressText="Import manuale completato!"
            isProcessing=false
            return
        }
        isProcessing=true
        let mov = pendingMovies[currentIndex]
        progressText="Cerco: \(mov.title)..."

        let yInt=Int(mov.year).flatMap{$0==0 ? nil:$0}
        Task {
            do {
                let results=try await TMDbService.shared.search(
                    query: mov.title,
                    mediaType: mov.isTV ? .tv:.movie,
                    year: yInt
                )
                if let first=results.first {
                    let imgResp = try await TMDbService.shared.fetchImages(for: first.id, mediaType: mov.isTV ? .tv:.movie)
                    let subset = imgResp.posters.prefix(16)
                    var images:[UIImage]=[]
                    for p in subset {
                        if let downloaded=try await TMDbService.shared.downloadImage(path: p.file_path){
                            images.append(downloaded)
                        }
                    }
                    await MainActor.run {
                        self.posterImages=images
                        self.isProcessing=false
                        self.progressText="Seleziona poster per \(mov.title)"
                        self.showingManualSheet=true
                    }
                } else {
                    await MainActor.run {
                        self.isProcessing=false
                        self.finishCurrentMovie(nil)
                    }
                }
            } catch {
                await MainActor.run {
                    self.isProcessing=false
                    self.finishCurrentMovie(nil)
                }
            }
        }
    }

    @ViewBuilder
    private func manualSelectionSheet() -> some View {
        let mov = pendingMovies[currentIndex]
        VStack {
            Text("Scegli Poster per \(mov.title)")
                .font(.headline)
                .padding()

            if posterImages.isEmpty {
                Text("Nessuna locandina trovata.")
                    .padding()
                Button("Avanti") {
                    showingManualSheet=false
                    finishCurrentMovie(nil)
                }
                Button("Film sbagliato") {
                    showingManualSheet=false
                    self.searchQuery=mov.title
                    self.isTV=mov.isTV
                    if let y=Int(mov.year), y != 0 {
                        yearGuess=y
                    } else {
                        yearGuess=nil
                    }
                    showingWrongFilmSheet=true
                }
            } else {
                ScrollView {
                    LazyVGrid(columns:[GridItem(.flexible()), GridItem(.flexible())], spacing:10){
                        ForEach(0..<posterImages.count, id:\.self) { i in
                            Button {
                                chosenPoster=posterImages[i]
                                showingManualSheet=false
                                finishCurrentMovie(chosenPoster)
                            } label: {
                                Image(uiImage: posterImages[i])
                                    .resizable()
                                    .scaledToFit()
                            }
                        }
                    }
                    .padding()
                }
                Button("Film sbagliato") {
                    showingManualSheet=false
                    self.searchQuery=mov.title
                    self.isTV=mov.isTV
                    if let y=Int(mov.year), y != 0 {
                        yearGuess=y
                    } else {
                        yearGuess=nil
                    }
                    showingWrongFilmSheet=true
                }
                .padding(.top,12)
            }
        }
        .padding()
    }

    private func finishCurrentMovie(_ chosen: UIImage?) {
        let mov = pendingMovies[currentIndex]
        if let img=chosen {
            // Carichiamo i dati TMDb in italiano
            Task {
                do {
                    // Cerchiamo nuovamente, prendiamo il primo
                    let yInt = Int(mov.year).flatMap{$0==0 ? nil:$0}
                    let results=try await TMDbService.shared.search(
                        query: mov.title,
                        mediaType: mov.isTV ? .tv:.movie,
                        year:yInt
                    )
                    if let first=results.first {
                        let details=try await fetchTMDbDetails(itemID: first.id, isTV: mov.isTV)
                        let finalMovie=MovieModel(
                            title: details.title,
                            year: details.year,
                            rating: mov.rating,
                            dateWatched: mov.dateWatched,
                            isTV: mov.isTV
                        )
                        let item=PosterItem(
                            id: UUID(),
                            movie: finalMovie,
                            uiImage: img,
                            timestamp: Date(),
                            imageFilename:nil
                        )
                        await MainActor.run {
                            libraryVM.addPoster(item)
                        }
                    } else {
                        // fallback, non trovato
                        let item=PosterItem(
                            id: UUID(),
                            movie: mov,
                            uiImage: img,
                            timestamp: Date(),
                            imageFilename:nil
                        )
                        await MainActor.run {
                            libraryVM.addPoster(item)
                        }
                    }
                } catch {
                    let item=PosterItem(
                        id: UUID(),
                        movie: mov,
                        uiImage: img,
                        timestamp: Date(),
                        imageFilename:nil
                    )
                    await MainActor.run {
                        libraryVM.addPoster(item)
                    }
                }
            }
        }
        currentIndex+=1
        showNextManualStep()
    }

    // MARK: - WrongFilmSheet
    @ViewBuilder
    private func wrongFilmSheet() -> some View {
        NavigationView {
            VStack {
                TextField("Nome Film/Serie", text:$searchQuery)
                    .padding()
                Toggle("È una Serie TV?", isOn:$isTV)
                    .padding(.horizontal)
                HStack {
                    Text("Anno (opzionale):")
                    TextField("Es: 2023", value:$yearGuess, format:.number)
                        .keyboardType(.numberPad)
                }
                .padding(.horizontal)

                Button("Cerca su TMDb") {
                    Task { await doManualSearch() }
                }
                .padding()

                if searchResults.isEmpty {
                    Text("Nessun risultato.").padding()
                } else {
                    List {
                        ForEach(searchResults, id:\.id){ r in
                            Button {
                                pickSearchResult(r)
                            } label: {
                                let name = isTV ? (r.name ?? "") : (r.title ?? "")
                                let y = isTV ? r.first_air_date : r.release_date
                                Text("\(name) (\(y?.prefix(4) ?? "????"))")
                            }
                        }
                    }
                }
                Spacer()
            }
            .navigationBarItems(trailing:
                Button("Chiudi") {
                    showingWrongFilmSheet=false
                }
            )
            .navigationTitle("Scegli Film Corretto")
        }
    }

    private func pickSearchResult(_ r: TMDbService.TMDbSearchResult) {
        let mov = pendingMovies[currentIndex]
        showingWrongFilmSheet=false
        isProcessing=true
        progressText="Carico locandine alternative..."

        Task {
            do {
                let imgResp = try await TMDbService.shared.fetchImages(for: r.id, mediaType: mov.isTV ? .tv:.movie)
                let subset = imgResp.posters.prefix(16)
                var images:[UIImage]=[]
                for p in subset {
                    if let downloaded=try await TMDbService.shared.downloadImage(path:p.file_path) {
                        images.append(downloaded)
                    }
                }
                await MainActor.run {
                    self.posterImages=images
                    self.isProcessing=false
                    self.showingManualSheet=true
                    self.progressText="Seleziona poster per \(mov.title)"
                }
            } catch {
                await MainActor.run {
                    self.isProcessing=false
                    self.finishCurrentMovie(nil)
                }
            }
        }
    }

    private func doManualSearch() async {
        searchResults=[]
        guard !searchQuery.isEmpty else{return}
        let type = isTV ? TMDbService.MediaType.tv : .movie
        do {
            let arr=try await TMDbService.shared.search(query: searchQuery, mediaType:type, year: yearGuess)
            self.searchResults=arr
        } catch {
            print("Errore manual search: \(error.localizedDescription)")
        }
    }

    // MARK: - Funzione per caricare i dettagli (title+year) in italiano
    private func fetchTMDbDetails(itemID:Int, isTV:Bool) async throws -> (title:String, year:String) {
        // In un progetto reale useremmo un'API separate (es. /movie/{id}?language=it-IT).
        // Qui, semplifichiamo: rifacciamo la search per “info”
        if isTV {
            // TV details
            let urlString = "https://api.themoviedb.org/3/tv/\(itemID)?api_key=\(TMDbService.shared.apiKey)&language=it-IT"
            guard let url=URL(string:urlString) else { throw URLError(.badURL) }
            let (data,_)=try await URLSession.shared.data(from:url)
            let info = try JSONDecoder().decode(TVDetails.self, from:data)
            let name = info.name.isEmpty ? (info.original_name ?? "??") : info.name
            let first = info.first_air_date ?? ""
            let year = first.count>=4 ? String(first.prefix(4)) : "????"
            return (name,year)
        } else {
            // Movie details
            let urlString = "https://api.themoviedb.org/3/movie/\(itemID)?api_key=\(TMDbService.shared.apiKey)&language=it-IT"
            guard let url=URL(string:urlString) else { throw URLError(.badURL) }
            let (data,_)=try await URLSession.shared.data(from:url)
            let info = try JSONDecoder().decode(MovieDetails.self, from:data)
            let title = info.title.isEmpty ? (info.original_title ?? "??") : info.title
            let rd = info.release_date ?? ""
            let year = rd.count>=4 ? String(rd.prefix(4)) : "????"
            return (title, year)
        }
    }
}

// MARK: - Struct per decoding
fileprivate struct MovieDetails: Codable {
    let title:String
    let original_title:String?
    let release_date:String?
}
fileprivate struct TVDetails: Codable {
    let name:String
    let original_name:String?
    let first_air_date:String?
}


========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForge/Views/ContentView.swift
========================================
import SwiftUI

struct ContentView: View {
    @EnvironmentObject var preferencesManager: PreferencesManager
    @StateObject var libraryVM = LibraryViewModel()
    
    @State private var activeSheet: ActiveSheet?
    
    enum ActiveSheet: Identifiable {
        case settings, csvImport, search, library
        var id:Int{hashValue}
    }

    var body: some View {
        NavigationView {
            ZStack {
                LinearGradient(gradient: Gradient(colors:[
                    Color(red:0.1,green:0.1,blue:0.1),
                    Color(red:0.2,green:0.2,blue:0.2)]),
                    startPoint:.top, endPoint:.bottom
                )
                .edgesIgnoringSafeArea(.all)

                VStack(spacing:40){
                    Spacer()
                    VStack(spacing:12){
                        Text("PosterForge")
                            .font(.largeTitle)
                            .fontWeight(.heavy)
                            .foregroundColor(.white)
                        Text("Crea e gestisci i tuoi poster personalizzati")
                            .font(.headline)
                            .foregroundColor(.white.opacity(0.8))
                            .multilineTextAlignment(.center)
                    }
                    VStack(spacing:20){
                        actionButton("Carica CSV", icon:"tray.and.arrow.down", sheet:.csvImport)
                        actionButton("Cerca Film/Serie", icon:"magnifyingglass", sheet:.search)
                        actionButton("Mostra Libreria", icon:"photo.stack", sheet:.library)
                    }
                    Spacer()
                }
                .padding()
            }
            .navigationBarItems(trailing: Button {
                activeSheet=.settings
            } label:{
                Image(systemName:"gearshape").foregroundColor(.white)
            })
            .sheet(item: $activeSheet){sheet in
                switch sheet {
                case .settings:
                    SettingsView()
                case .csvImport:
                    CSVImportView(libraryVM: libraryVM)
                case .search:
                    SearchView(libraryVM: libraryVM)
                case .library:
                    LibraryView(libraryVM: libraryVM)
                }
            }
        }
    }

    @ViewBuilder
    private func actionButton(_ title:String, icon:String, sheet:ActiveSheet)-> some View {
        Button {
            activeSheet=sheet
        } label:{
            HStack{
                Image(systemName:icon)
                Text(title)
            }
            .font(.title3)
            .foregroundColor(.white)
            .padding()
            .background(Color.black.opacity(0.3))
            .cornerRadius(12)
        }
    }
}


========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForge/Views/LibraryView.swift
========================================
import SwiftUI

struct LibraryView: View {
    @ObservedObject var libraryVM: LibraryViewModel
    @Environment(\.presentationMode) var presentationMode

    @State private var selectedPosterItem: PosterItem?
    @State private var showingDetail = false

    // Multi-selezione
    @State private var selectionMode = false
    @State private var selectedItems: Set<UUID> = []

    private let columns = [
        GridItem(.flexible()),
        GridItem(.flexible()),
        GridItem(.flexible())
    ]

    var body: some View {
        NavigationView {
            VStack {
                if libraryVM.posters.isEmpty {
                    Text("La tua libreria è vuota.\nImporta un CSV o cerca un film!")
                        .multilineTextAlignment(.center)
                        .padding()
                } else {
                    ScrollView {
                        LazyVGrid(columns: columns, spacing: 10) {
                            ForEach(sortedPosters) { poster in
                                LibraryPosterCell(
                                    poster: poster,
                                    isSelected: selectionMode && selectedItems.contains(poster.id)
                                ) {
                                    if selectionMode {
                                        toggleSelection(poster.id)
                                    } else {
                                        selectedPosterItem = poster
                                        showingDetail = true
                                    }
                                }
                            }
                        }
                        .padding()
                    }
                }

                if selectionMode && !selectedItems.isEmpty {
                    HStack(spacing: 40) {
                        Button("Scarica selezionati") {
                            showLayoutChoiceForMultiple()
                        }
                        Button("Elimina selezionati") {
                            removeSelectedPosters()
                        }
                    }
                    .padding(.bottom, 20)
                }
            }
            .navigationTitle("La mia Libreria")
            .navigationBarItems(
                leading: Button("Chiudi") {
                    presentationMode.wrappedValue.dismiss()
                },
                trailing: Button(selectionMode ? "Fine" : "Seleziona") {
                    selectionMode.toggle()
                    if !selectionMode {
                        selectedItems.removeAll()
                    }
                }
            )
            .sheet(item: $selectedPosterItem) { item in
                PosterDetailView(posterItem: item)
                    .environmentObject(libraryVM)
            }
        }
    }

    var sortedPosters: [PosterItem] {
        libraryVM.posters.sorted { $0.timestamp > $1.timestamp }
    }

    private func toggleSelection(_ id: UUID) {
        if selectedItems.contains(id) {
            selectedItems.remove(id)
        } else {
            selectedItems.insert(id)
        }
    }

    private func removeSelectedPosters() {
        let toRemove = sortedPosters.filter{selectedItems.contains($0.id)}
        for p in toRemove {
            libraryVM.removePoster(p)
        }
        selectedItems.removeAll()
        selectionMode=false
    }

    private func showLayoutChoiceForMultiple() {
        let alert = UIAlertController(
            title:"Operazione",
            message:"Come vuoi scaricare i poster selezionati?",
            preferredStyle:.actionSheet
        )
        alert.addAction(UIAlertAction(title:"Poster grezzo", style:.default, handler:{ _ in
            downloadMultipleRaw()
        }))
        alert.addAction(UIAlertAction(title:"Layout Tradizionale", style:.default, handler:{ _ in
            generateAndSaveMultiple(layout:"traditional")
        }))
        alert.addAction(UIAlertAction(title:"Layout Moderno", style:.default, handler:{ _ in
            generateAndSaveMultiple(layout:"modern")
        }))
        alert.addAction(UIAlertAction(title:"Annulla", style:.cancel, handler:nil))

        if let scene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let window=scene.windows.first,
           let root=window.rootViewController {
            
            if let pop = alert.popoverPresentationController {
                pop.sourceView=window
                pop.sourceRect=CGRect(x: window.bounds.midX, y: window.bounds.maxY, width:0,height:0)
                pop.permittedArrowDirections=[]
            }
            root.present(alert, animated:true)
        }
    }

    private func downloadMultipleRaw() {
        for p in sortedPosters where selectedItems.contains(p.id) {
            if let base=p.uiImage {
                UIImageWriteToSavedPhotosAlbum(base, nil, nil, nil)
            }
        }
        selectedItems.removeAll()
        selectionMode=false
    }

    private func generateAndSaveMultiple(layout:String) {
        for p in sortedPosters where selectedItems.contains(p.id) {
            guard let base=p.uiImage else{continue}
            if let newImg = PosterGenerator.shared.generatePoster(baseImage:base, layout:layout, movie:p.movie){
                UIImageWriteToSavedPhotosAlbum(newImg, nil, nil, nil)
            }
        }
        selectedItems.removeAll()
        selectionMode=false
    }
}

struct LibraryPosterCell: View {
    let poster: PosterItem
    let isSelected: Bool
    let tapAction: ()->Void

    var body: some View {
        ZStack(alignment:.topTrailing) {
            poster.image
                .resizable()
                .scaledToFit()
                .cornerRadius(8)
                .shadow(radius:2)
                .onTapGesture{ tapAction() }

            if isSelected {
                Image(systemName:"checkmark.circle.fill")
                    .foregroundColor(.blue)
                    .padding(5)
            }
        }
        .overlay(
            Text("\(poster.movie.title) (\(poster.movie.year))")
                .font(.caption)
                .padding(4)
                .background(Color.black.opacity(0.5))
                .foregroundColor(.white),
            alignment: .bottom
        )
    }
}


========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForge/Views/PosterDetailView.swift
========================================
import SwiftUI
import UIKit

struct ActivityViewControllerWrapper: UIViewControllerRepresentable {
    let activityItems:[Any]
    let applicationActivities:[UIActivity]?=nil
    func makeUIViewController(context:Context)->UIActivityViewController {
        UIActivityViewController(activityItems:activityItems, applicationActivities:applicationActivities)
    }
    func updateUIViewController(_ uiViewController:UIActivityViewController, context:Context){}
}

struct PosterDetailView: View, Identifiable {
    var id: UUID { posterItem.id }
    let posterItem: PosterItem
    @EnvironmentObject var libraryVM: LibraryViewModel

    @State private var generatedPoster: UIImage?
    @State private var showGeneratedFullScreen=false
    @State private var showingChangeSheet=false
    @State private var searchResults:[TMDbService.TMDbSearchResult]=[]
    @State private var newImages:[UIImage]=[]
    @State private var isTV = false
    @State private var query="" // per la manual search
    @State private var yearGuess:Int?=nil
    @State private var isProcessing=false

    var body: some View {
        NavigationView {
            VStack {
                posterItem.image
                    .resizable()
                    .scaledToFit()
                    .padding()

                Text(posterItem.movie.title)
                    .font(.title)
                    .fontWeight(.bold)
                Text("Anno: \(posterItem.movie.year)")
                Text("Voto: \(posterItem.movie.rating)/10")
                Text("Data visione: \(posterItem.movie.dateWatched)")
                    .font(.subheadline)
                    .foregroundColor(.secondary)

                Divider().padding()

                Spacer()

                HStack {
                    Button("Poster Tradizionale") {
                        generatePoster(layout:"traditional")
                    }.padding()

                    Button("Poster Moderno") {
                        generatePoster(layout:"modern")
                    }.padding()
                }

                Button("Scarica Poster Grezzo") {
                    if let base=posterItem.uiImage {
                        UIImageWriteToSavedPhotosAlbum(base, nil, nil, nil)
                    }
                }

                Button("Cambia Locandina") {
                    // Apertura di un sheet per fare la ricerca
                    isTV=posterItem.movie.isTV
                    query=posterItem.movie.title
                    if let y=Int(posterItem.movie.year) { yearGuess=y }
                    else { yearGuess=nil }
                    showingChangeSheet=true
                }
                .padding(.bottom, 20)
            }
            .navigationTitle("Dettagli Poster")
            .navigationBarTitleDisplayMode(.inline)
            .sheet(isPresented:$showGeneratedFullScreen) {
                if let g=generatedPoster {
                    FullScreenPosterView(uiImage:g, onClose:{ showGeneratedFullScreen=false })
                }
            }
            .sheet(isPresented:$showingChangeSheet) {
                changePosterSheet()
            }
        }
        .navigationViewStyle(StackNavigationViewStyle())
    }

    private func generatePoster(layout:String) {
        guard let base=posterItem.uiImage else{return}
        let newImg=PosterGenerator.shared.generatePoster(baseImage:base, layout:layout, movie:posterItem.movie)
        self.generatedPoster=newImg
        showGeneratedFullScreen=true
    }

    // Sheet per cambiare locandina
    @ViewBuilder
    private func changePosterSheet()-> some View {
        NavigationView {
            VStack {
                if isProcessing {
                    ProgressView("Caricamento...").padding()
                } else if !newImages.isEmpty {
                    ScrollView {
                        LazyVGrid(columns:[GridItem(.flexible()), GridItem(.flexible())], spacing:10){
                            ForEach(0..<newImages.count, id:\.self) { i in
                                Button {
                                    applyNewPoster(newImages[i])
                                } label:{
                                    Image(uiImage:newImages[i])
                                        .resizable()
                                        .scaledToFit()
                                }
                            }
                        }
                        .padding()
                    }
                } else if !searchResults.isEmpty {
                    Text("Seleziona poster in base ai result")
                    // Non forziamo un passaggio intermedio con locandine?
                    // Potremmo auto-scaricare. Facciamo un pulsante
                    List(searchResults, id:\.id){ r in
                        Button {
                            loadPostersFrom(r)
                        } label:{
                            let nm = isTV ? (r.name ?? "") : (r.title ?? "")
                            let y = isTV ? r.first_air_date : r.release_date
                            Text("\(nm) (\(y?.prefix(4) ?? "????"))")
                        }
                    }
                } else {
                    Form {
                        TextField("Titolo", text:$query)
                        Toggle("È Serie TV?", isOn:$isTV)
                        TextField("Anno (opzionale)", value:$yearGuess, format:.number)
                            .keyboardType(.numberPad)
                        Button("Cerca su TMDb") {
                            Task { await doSearchChange() }
                        }
                    }
                }
            }
            .navigationBarItems(trailing: Button("Chiudi"){ showingChangeSheet=false })
            .navigationTitle("Cambia Locandina")
        }
    }

    private func applyNewPoster(_ newPoster:UIImage) {
        // Scarichiamo i dati in italiano
        showingChangeSheet=false
        isProcessing=true
        Task {
            do {
                // rifacciamo search
                let yInt=yearGuess
                let results=try await TMDbService.shared.search(
                    query: query,
                    mediaType: isTV ? .tv:.movie,
                    year:yInt
                )
                if let first=results.first {
                    // fetch dettagli
                    let details=try await fetchTMDbDetails(itemID:first.id, isTV:isTV)
                    // Creiamo un MovieModel aggiornato (ma manteniamo rating e dateWatched)
                    let old = posterItem.movie
                    let newMov=MovieModel(
                        title: details.title,
                        year: details.year,
                        rating: old.rating,
                        dateWatched: old.dateWatched,
                        isTV: old.isTV
                    )
                    // Rimuoviamo il vecchio poster e aggiungiamo quello nuovo
                    libraryVM.removePoster(posterItem)
                    let updated=PosterItem(
                        id: UUID(),
                        movie:newMov,
                        uiImage:newPoster,
                        timestamp: Date(),
                        imageFilename:nil
                    )
                    libraryVM.addPoster(updated)
                }
            } catch {
                // fallback: manteniamo i dati vecchi e aggiorniamo la sola immagine
                libraryVM.removePoster(posterItem)
                let updated=PosterItem(
                    id: UUID(),
                    movie: posterItem.movie,
                    uiImage:newPoster,
                    timestamp:Date(),
                    imageFilename:nil
                )
                libraryVM.addPoster(updated)
            }
            isProcessing=false
        }
    }

    private func loadPostersFrom(_ r:TMDbService.TMDbSearchResult) {
        isProcessing=true
        newImages=[]
        Task {
            do {
                let info = try await TMDbService.shared.fetchImages(for:r.id, mediaType: isTV ? .tv:.movie)
                let subset = info.posters.prefix(16)
                var tmp:[UIImage]=[]
                for p in subset {
                    if let d=try await TMDbService.shared.downloadImage(path:p.file_path) {
                        tmp.append(d)
                    }
                }
                await MainActor.run {
                    newImages=tmp
                    isProcessing=false
                }
            } catch {
                await MainActor.run {
                    isProcessing=false
                }
            }
        }
    }

    private func doSearchChange() async {
        searchResults=[]
        newImages=[]
        isProcessing=true
        defer{isProcessing=false}
        do {
            let results=try await TMDbService.shared.search(
                query: query,
                mediaType: isTV ? .tv:.movie,
                year: yearGuess
            )
            searchResults=results
        } catch {
            print("Errore doSearchChange:", error.localizedDescription)
        }
    }

    private func fetchTMDbDetails(itemID:Int, isTV:Bool) async throws -> (title:String, year:String) {
        if isTV {
            let urlString="https://api.themoviedb.org/3/tv/\(itemID)?api_key=\(TMDbService.shared.apiKey)&language=it-IT"
            guard let url=URL(string:urlString) else{throw URLError(.badURL)}
            let (data,_)=try await URLSession.shared.data(from:url)
            let info=try JSONDecoder().decode(TVDetails.self, from:data)
            let nm = info.name.isEmpty ? (info.original_name ?? "??") : info.name
            let fd = info.first_air_date ?? ""
            let y = fd.count>=4 ? String(fd.prefix(4)):"????"
            return (nm,y)
        } else {
            let urlString="https://api.themoviedb.org/3/movie/\(itemID)?api_key=\(TMDbService.shared.apiKey)&language=it-IT"
            guard let url=URL(string:urlString) else{throw URLError(.badURL)}
            let (data,_)=try await URLSession.shared.data(from:url)
            let info=try JSONDecoder().decode(MovieDetails.self, from:data)
            let ti = info.title.isEmpty ? (info.original_title ?? "??") : info.title
            let rd = info.release_date ?? ""
            let y = rd.count>=4 ? String(rd.prefix(4)):"????"
            return(ti,y)
        }
    }
}

// Stesse struct di supporto
fileprivate struct MovieDetails:Codable {
    let title:String
    let original_title:String?
    let release_date:String?
}
fileprivate struct TVDetails:Codable {
    let name:String
    let original_name:String?
    let first_air_date:String?
}


========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForge/Views/SearchView.swift
========================================
import SwiftUI

struct SearchView: View {
    @ObservedObject var libraryVM: LibraryViewModel
    @EnvironmentObject var preferencesManager: PreferencesManager
    @Environment(\.presentationMode) var presentationMode

    @State private var query=""
    @State private var isTV=false
    @State private var results:[TMDbService.TMDbSearchResult]=[]

    @State private var selectedYear=""
    @State private var userRating=5
    @State private var dateWatched=""

    @State private var posterImages:[UIImage]=[]
    @State private var chosenPoster:UIImage?
    @State private var selectedItem:TMDbService.TMDbSearchResult?

    @State private var phase=0

    private let columns=[GridItem(.flexible()), GridItem(.flexible())]

    var body: some View {
        NavigationView {
            Group {
                switch phase {
                case 0: phase0View()
                case 1: phase1View()
                case 2: phase2View()
                default: phase3View()
                }
            }
            .navigationTitle("Cerca Film/Serie")
            .navigationBarItems(leading: Button("Annulla"){
                presentationMode.wrappedValue.dismiss()
            })
            .onAppear{ resetState() }
        }
    }

    // Fase 0
    @ViewBuilder
    private func phase0View()-> some View {
        Form {
            Section(header:Text("Dati Film/Serie")) {
                TextField("Nome Film/Serie", text:$query)
                Toggle("È una Serie TV?", isOn:$isTV)
                TextField("Anno (opzionale)", text:$selectedYear).keyboardType(.numberPad)
            }
            Section(header:Text("Tuoi dati/Rating")) {
                Stepper("Voto (1-10): \(userRating)", value:$userRating, in:1...10)
                TextField("Data visione (AAAA-MM-GG)", text:$dateWatched)
            }
            Section {
                Button("Cerca"){search()}
            }
        }
    }

    // Fase 1: Risultati
    @ViewBuilder
    private func phase1View()-> some View {
        VStack {
            if results.isEmpty {
                Text("Nessun risultato trovato.").padding()
            } else {
                List(results, id:\.id){ item in
                    Button {
                        handleResultSelection(item)
                    } label:{
                        Text("\(item.displayTitle) (\(item.releaseYear))")
                    }
                }
            }
        }
    }

    // Fase 2: Selezione poster
    @ViewBuilder
    private func phase2View()-> some View {
        VStack {
            Text("Scegli Poster")
                .font(.headline)
                .padding()
            ScrollView {
                LazyVGrid(columns:columns, spacing:10) {
                    ForEach(0..<posterImages.count, id:\.self){ i in
                        Button {
                            chosenPoster=posterImages[i]
                            generateFinalPoster()
                        } label:{
                            Image(uiImage:posterImages[i])
                                .resizable()
                                .scaledToFit()
                                .frame(minWidth:0, maxWidth:.infinity)
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                }
                .padding()
            }
        }
    }

    // Fase 3: completato
    @ViewBuilder
    private func phase3View()-> some View {
        VStack(spacing:20){
            Text("Poster generato e aggiunto in libreria!")
                .font(.title2)
                .padding()
            Button("Fine"){
                presentationMode.wrappedValue.dismiss()
            }.padding()
        }
    }

    // MARK: - Logica
    private func search() {
        phase=1
        results=[]
        posterImages=[]
        chosenPoster=nil
        Task {
            do {
                let yInt=Int(selectedYear)
                let found=try await TMDbService.shared.search(
                    query:query,
                    mediaType:isTV ? .tv:.movie,
                    year:yInt
                )
                results=found
            } catch {
                print("Errore ricerca:", error.localizedDescription)
            }
        }
    }

    private func handleResultSelection(_ item:TMDbService.TMDbSearchResult) {
        selectedItem=item
        let y = isTV ? item.first_air_date : item.release_date
        if let ys=y, ys.count>=4, selectedYear.isEmpty {
            selectedYear=String(ys.prefix(4))
        }
        fetchPosters(for:item)
    }

    private func fetchPosters(for item:TMDbService.TMDbSearchResult) {
        Task {
            do {
                let imagesResp=try await TMDbService.shared.fetchImages(
                    for:item.id,
                    mediaType:isTV ? .tv:.movie
                )
                let subset = imagesResp.posters.prefix(16)
                var arr:[UIImage]=[]
                for p in subset {
                    if let d=try await TMDbService.shared.downloadImage(path:p.file_path){
                        arr.append(d)
                    }
                }
                await MainActor.run {
                    posterImages=arr
                    phase=2
                }
            } catch {
                print("Errore fetch poster:", error.localizedDescription)
                await MainActor.run{
                    phase=0
                }
            }
        }
    }

    private func generateFinalPoster() {
        guard let base=chosenPoster, let sel=selectedItem else{return}
        // Carichiamo i dettagli in italiano
        Task {
            do {
                let det=try await fetchTMDbDetails(itemID: sel.id, isTV: isTV)
                // Costruiamo un MovieModel con rating e date visti dall’utente
                let finalMovie=MovieModel(
                    title: det.title,
                    year: det.year,
                    rating: userRating,
                    dateWatched: dateWatched,
                    isTV: isTV
                )
                let item=PosterItem(
                    id: UUID(),
                    movie: finalMovie,
                    uiImage: base,
                    timestamp:Date(),
                    imageFilename:nil
                )
                libraryVM.addPoster(item)
                phase=3
            } catch {
                print("Errore details:", error.localizedDescription)
                // fallback: usiamo query
                let fallback=MovieModel(
                    title: query,
                    year: selectedYear,
                    rating: userRating,
                    dateWatched: dateWatched,
                    isTV: isTV
                )
                let item=PosterItem(
                    id:UUID(),
                    movie:fallback,
                    uiImage:base,
                    timestamp:Date(),
                    imageFilename:nil
                )
                libraryVM.addPoster(item)
                phase=3
            }
        }
    }

    private func resetState() {
        query=""
        selectedYear=""
        userRating=5
        dateWatched=""
        phase=0
        results=[]
        posterImages=[]
        chosenPoster=nil
    }

    private func fetchTMDbDetails(itemID:Int, isTV:Bool) async throws -> (title:String, year:String) {
        if isTV {
            let urlString="https://api.themoviedb.org/3/tv/\(itemID)?api_key=\(TMDbService.shared.apiKey)&language=it-IT"
            guard let url=URL(string:urlString) else{throw URLError(.badURL)}
            let (data,_)=try await URLSession.shared.data(from:url)
            let info=try JSONDecoder().decode(TVDetails.self, from:data)
            let nm = info.name.isEmpty ? (info.original_name ?? "??") : info.name
            let fd = info.first_air_date ?? ""
            let y = fd.count>=4 ? String(fd.prefix(4)):"????"
            return(nm,y)
        } else {
            let urlString="https://api.themoviedb.org/3/movie/\(itemID)?api_key=\(TMDbService.shared.apiKey)&language=it-IT"
            guard let url=URL(string:urlString) else{throw URLError(.badURL)}
            let (data,_)=try await URLSession.shared.data(from:url)
            let info=try JSONDecoder().decode(MovieDetails.self, from:data)
            let ti = info.title.isEmpty ? (info.original_title ?? "??") : info.title
            let rd = info.release_date ?? ""
            let y = rd.count>=4 ? String(rd.prefix(4)):"????"
            return(ti,y)
        }
    }
}

// MARK: - Stessa struct supporto
fileprivate struct MovieDetails:Codable {
    let title:String
    let original_title:String?
    let release_date:String?
}
fileprivate struct TVDetails:Codable {
    let name:String
    let original_name:String?
    let first_air_date:String?
}


========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForge/Views/SettingsView.swift
========================================
import SwiftUI

struct SettingsView: View {
    @EnvironmentObject var preferencesManager: PreferencesManager
    @Environment(\.presentationMode) var presentationMode

    @State private var showingResetAlert=false

    var body: some View {
        NavigationView {
            Form {
                Section(header:Text("Modalità selezione locandine")) {
                    Picker("Scelta locandine", selection:$preferencesManager.preferences.posterSelectionMode) {
                        Text("Automatica").tag("automatic")
                        Text("Manuale").tag("manual")
                    }
                    .pickerStyle(SegmentedPickerStyle())
                }
                Section {
                    Button("Reset libreria"){
                        showingResetAlert=true
                    }
                    .alert(isPresented:$showingResetAlert){
                        Alert(
                            title:Text("Conferma cancellazione"),
                            message:Text("Vuoi davvero cancellare tutte le copertine della libreria? L'operazione è irreversibile."),
                            primaryButton:.destructive(Text("Sì, cancella")){
                                resetLibrary()
                            },
                            secondaryButton:.cancel(Text("Annulla"))
                        )
                    }
                }
                Section {
                    Button("Salva e chiudi"){
                        preferencesManager.savePreferences()
                        presentationMode.wrappedValue.dismiss()
                    }
                }
            }
            .navigationTitle("Impostazioni")
        }
    }

    private func resetLibrary() {
        preferencesManager.savePreferences()
        NotificationCenter.default.post(name: .libraryResetRequested, object:nil)
    }
}

extension Notification.Name {
    static let libraryResetRequested=Notification.Name("libraryResetRequested")
}


========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForge/Services/CSVParser.swift
========================================
import SwiftUI

class CSVParser {
    static func parseMovies(from csvContent:String)->[MovieModel] {
        var results:[MovieModel]=[]
        let lines=csvContent.components(separatedBy:.newlines)
        guard lines.count>1 else {
            print("ERRORE CSVParser: Meno di 2 righe nel CSV; impossibile parse.")
            return[]
        }
        let headerLine=lines[0]
        let header=headerLine.split(separator:",").map{ String($0).trimmingCharacters(in:.whitespaces)}

        let tIndex = header.firstIndex(of:"Original Title")
        let yIndex = header.firstIndex(of:"Year")
        let rIndex = header.firstIndex(of:"Your Rating")
        let dIndex = header.firstIndex(of:"Date Rated")
        let typeIndex = header.firstIndex(of:"Title Type")
        if tIndex==nil || yIndex==nil || rIndex==nil || dIndex==nil || typeIndex==nil {
            print("ERRORE CSVParser: Colonne richieste mancanti (Original Title, Year, Your Rating, Date Rated, Title Type).")
            return[]
        }
        for i in 1..<lines.count {
            let rawLine=lines[i].trimmingCharacters(in:.whitespaces)
            if rawLine.isEmpty {continue}
            let line=rawLine.split(separator:",", omittingEmptySubsequences:false)
                .map{String($0).trimmingCharacters(in:.whitespaces)}
            if line.count<header.count {continue}

            let csvTitle=line[tIndex!]
            let csvYear=line[yIndex!]
            let csvRating=line[rIndex!]
            let csvDate=line[dIndex!]
            let csvType=line[typeIndex!].lowercased()

            let isTV=csvType.contains("tv")
            let ratingInt=Int(csvRating) ?? 0
            let mov=MovieModel(
                title:csvTitle,
                year:csvYear,
                rating:ratingInt,
                dateWatched:csvDate,
                isTV:isTV
            )
            results.append(mov)
        }
        return results
    }
}


========================================
File: /Users/alexsiroli/Documents/Progetti/PosterForge/PosterForge/Services/TMDbService.swift
========================================
import Foundation
import os.log
import UIKit

class TMDbService {
    static let shared=TMDbService()

    let apiKey="8e7466051f04487c6a8248672c859497"
    private let baseURL="https://api.themoviedb.org/3/"
    private let imageBaseURL="https://image.tmdb.org/t/p/"
    private let session:URLSession
    private let logger=Logger(subsystem:"com.yourapp.PosterForge", category:"Network")

    private let imageCache=NSCache<NSString,UIImage>()

    init(configuration:URLSessionConfiguration = .default) {
        configuration.requestCachePolicy = .returnCacheDataElseLoad
        configuration.urlCache = URLCache.shared
        self.session=URLSession(configuration:configuration)
    }

    struct TMDbSearchResponse: Codable {
        let page:Int
        let results:[TMDbSearchResult]
        let total_pages:Int
        let total_results:Int
    }
    struct TMDbSearchResult: Codable, Identifiable {
        let id:Int
        let media_type:String?
        let title:String?
        let name:String?
        let poster_path:String?
        let backdrop_path:String?
        let release_date:String?
        let first_air_date:String?
        let vote_average:Double?
        let overview:String?

        var displayTitle:String {
            return title ?? name ?? "Unknown Title"
        }
        var releaseYear:String {
            let ds=release_date ?? first_air_date ?? ""
            return String(ds.prefix(4))
        }
    }

    struct TMDbImagesResponse: Codable {
        let posters:[TMDbImageInfo]
        let backdrops:[TMDbImageInfo]
    }
    struct TMDbImageInfo: Codable, Identifiable {
        var id:String{ file_path }
        let file_path:String
        let width:Int
        let height:Int
        let iso_639_1:String?
        let aspect_ratio:Double
        let vote_average:Double
        let vote_count:Int

        var url:URL? {
            URL(string:"\(TMDbService.shared.imageBaseURL)original\(file_path)")
        }
    }

    enum MediaType:String {
        case movie, tv
    }
    enum ImageSize:String {
        case small="w342"
        case medium="w500"
        case large="original"
    }
    enum TMDbError:Error,LocalizedError {
        case invalidURL
        case invalidResponse
        case statusCode(Int)
        case decodingError
        case imageDownloadFailed
        case invalidData
        var errorDescription:String?{
            switch self {
            case .invalidURL: return "URL non valida"
            case .invalidResponse: return "Risposta del server non valida"
            case .statusCode(let c): return "Errore server: \(c)"
            case .decodingError: return "Errore decodifica"
            case .imageDownloadFailed: return "Download immagine fallito"
            case .invalidData: return "Dati non validi"
            }
        }
    }

    // MARK: - Ricerca
    func search(query:String, mediaType:MediaType, year:Int?=nil, page:Int=1, language:String="it-IT", completion:@escaping(Result<[TMDbSearchResult],Error>)->Void) {
        let endpoint=(mediaType == .movie) ? "search/movie":"search/tv"
        guard var comp=URLComponents(string:"\(baseURL)\(endpoint)") else{
            completion(.failure(TMDbError.invalidURL));return
        }
        var qItems=[
            URLQueryItem(name:"api_key", value:apiKey),
            URLQueryItem(name:"query", value:query),
            URLQueryItem(name:"language", value:language),
            URLQueryItem(name:"page", value:"\(page)")
        ]
        if let y=year {
            if mediaType == .tv {
                qItems.append(URLQueryItem(name:"first_air_date_year", value:"\(y)"))
            } else {
                qItems.append(URLQueryItem(name:"year", value:"\(y)"))
            }
        }
        comp.queryItems=qItems
        guard let url=comp.url else{
            completion(.failure(TMDbError.invalidURL));return
        }
        performRequest(url:url){(res:Result<TMDbSearchResponse,Error>) in
            switch res {
            case .success(let r):
                completion(.success(r.results))
            case .failure(let e):
                completion(.failure(e))
            }
        }
    }

    // MARK: - Fetch immagini
    func fetchImages(for mediaId:Int, mediaType:MediaType, completion:@escaping(Result<TMDbImagesResponse,Error>)->Void ) {
        // Forziamo: null, it, en, fr, es, de, ru, ko, ja, ...
        let allLangs=["null","it","en","fr","es","de","ru","ko","ja","pt","zh"]
        let joined=allLangs.joined(separator:",")
        let endpoint="\(mediaType.rawValue)/\(mediaId)/images"
        guard var comp=URLComponents(string:"\(baseURL)\(endpoint)") else{
            completion(.failure(TMDbError.invalidURL));return
        }
        comp.queryItems=[
            URLQueryItem(name:"api_key", value:apiKey),
            URLQueryItem(name:"include_image_language", value:joined)
        ]
        guard let url=comp.url else{
            completion(.failure(TMDbError.invalidURL));return
        }

        performRequest(url:url){(res:Result<TMDbImagesResponse,Error>) in
            switch res {
            case .success(let raw):
                // Riordiniamo: nil->it->en->(tutto il resto)
                let reordered=raw.posters.sorted { p1,p2 in
                    let iso1=p1.iso_639_1 ?? "nil"
                    let iso2=p2.iso_639_1 ?? "nil"
                    if iso1==iso2 {return false}
                    if iso1=="nil" && iso2!="nil" {return true}
                    if iso2=="nil" && iso1!="nil" {return false}
                    if iso1=="it" && iso2!="it" {return true}
                    if iso2=="it" && iso1!="it" {return false}
                    if iso1=="en" && iso2!="en" {return true}
                    if iso2=="en" && iso1!="en" {return false}
                    // altrimenti non spostare
                    return false
                }
                let out=TMDbImagesResponse(posters:reordered, backdrops:raw.backdrops)
                completion(.success(out))
            case .failure(let e):
                completion(.failure(e))
            }
        }
    }

    // MARK: - Download immagine
    func downloadImage(path:String, size:ImageSize=.large, completion:@escaping(Result<UIImage,Error>)->Void) {
        let urlString="\(imageBaseURL)\(size.rawValue)\(path)"
        guard let url=URL(string:urlString) else{
            completion(.failure(TMDbError.invalidURL));return
        }
        if let c=imageCache.object(forKey: url.absoluteString as NSString) {
            completion(.success(c))
            return
        }
        session.dataTask(with:url){ data,_,err in
            if let e=err {
                completion(.failure(e));return
            }
            guard let d=data, let img=UIImage(data:d) else{
                completion(.failure(TMDbError.imageDownloadFailed));return
            }
            self.imageCache.setObject(img, forKey:url.absoluteString as NSString)
            completion(.success(img))
        }.resume()
    }

    // MARK: - Async
    @available(iOS 13.0,*)
    func search(query:String, mediaType:MediaType, year:Int?=nil, page:Int=1, language:String="it-IT") async throws -> [TMDbSearchResult] {
        try await withCheckedThrowingContinuation{ c in
            self.search(query:query, mediaType:mediaType, year:year, page:page, language:language){res in
                c.resume(with:res)
            }
        }
    }
    @available(iOS 13.0,*)
    func fetchImages(for mediaId:Int, mediaType:MediaType) async throws -> TMDbImagesResponse {
        try await withCheckedThrowingContinuation { c in
            self.fetchImages(for:mediaId, mediaType:mediaType){res in
                c.resume(with:res)
            }
        }
    }
    @available(iOS 13.0,*)
    func downloadImage(path:String, size:ImageSize=.large) async throws -> UIImage? {
        try await withCheckedThrowingContinuation{ cc in
            self.downloadImage(path:path, size:size){r in
                cc.resume(with:r)
            }
        }
    }

    // MARK: - Generic
    private func performRequest<T:Decodable>(url:URL, completion:@escaping(Result<T,Error>)->Void) {
        session.dataTask(with:url){ data,resp,err in
            if let e=err {
                DispatchQueue.main.async{
                    completion(.failure(e))
                }
                return
            }
            guard let http=resp as? HTTPURLResponse else{
                DispatchQueue.main.async{
                    completion(.failure(TMDbError.invalidResponse))
                }
                return
            }
            guard (200...299).contains(http.statusCode) else{
                DispatchQueue.main.async{
                    completion(.failure(TMDbError.statusCode(http.statusCode)))
                }
                return
            }
            guard let d=data else {
                DispatchQueue.main.async{
                    completion(.failure(TMDbError.invalidData))
                }
                return
            }
            do {
                let decoded=try JSONDecoder().decode(T.self, from:d)
                DispatchQueue.main.async{
                    completion(.success(decoded))
                }
            } catch {
                self.logger.error("Decoding error: \(error.localizedDescription)")
                DispatchQueue.main.async{
                    completion(.failure(TMDbError.decodingError))
                }
            }
        }.resume()
    }
}
